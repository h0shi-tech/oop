
# Лабораторная работа № 1 <!-- omit in toc -->
# Ввод-вывод <!-- omit in toc -->

- [1 Основы C++](#1-основы-c)
  - [1.1 Объявление данных: переменные](#11-объявление-данных-переменные)
  - [1.2 Действия над данными](#12-действия-над-данными)
    - [1.2.1 Управляющие конструкции языка](#121-управляющие-конструкции-языка)
    - [1.2.2 Операторы](#122-операторы)
  - [1.3 Заголовочные файлы](#13-заголовочные-файлы)
  - [1.4 Пространства имён](#14-пространства-имён)
  - [1.5 Классы и объекты](#15-классы-и-объекты)
  - [1.6 Ввод-вывод с помощью стандартной библиотеки C++](#16-ввод-вывод-с-помощью-стандартной-библиотеки-c)
    - [1.6.1 Заголовочный файл `<iostream>`](#161-заголовочный-файл-iostream)
    - [1.6.2 Форматированный вывод: заголовочный файл `<iomanip>`](#162-форматированный-вывод-заголовочный-файл-iomanip)
    - [1.6.3 Форматированный вывод: заголовочный файл `<format>`](#163-форматированный-вывод-заголовочный-файл-format)
  - [1.7 Пример](#17-пример)
- [2 Обязательное задание](#2-обязательное-задание)
  - [2.1 Общее задание](#21-общее-задание)
  - [2.2 Варианты](#22-варианты)
  - [2.3 Нормы](#23-нормы)
  - [2.4 Пример](#24-пример)
- [3 Факультативное задание](#3-факультативное-задание)

# 1 Основы C++

Любая компьютерная программа на самом абстрактном уровне занимается только одной задачей - обработкой данных.
Для обработки данных необходимо уметь:
- **объявлять данные;**
- **выполнять над ними действия.**

## 1.1 Объявление данных: переменные

Любые данные в программе хранятся в переменных, которые объявляются следующим образом:
```
тип_переменной имя_переменной;
```

Вот некоторые стандартные примитивные типы, доступные в C++:
- `bool` - логическое значение (флаг), может принимать одно из двух предопределённых значений:
  `true` (истина) или `false` (ложь).
- `int` - целое число со знаком;
- `unsigned int` - целое число без знака;
- `float` - вещественное значение одинарной точности
  (обычно это `binary32` из стандарта [IEE 754](https://ru.wikipedia.org/w/index.php?title=IEEE_754-2008&stable=1));
- `double` - вещественное значение двойной точности
  (обычно это `binary64` из стандарта [IEE 754](https://ru.wikipedia.org/w/index.php?title=IEEE_754-2008&stable=1)).

⚠ Точный диапазон значений конкретного типа определяется не на уровне стандарта, а конкретным компилятором.
Это означает, что для одного и того же типа допустимый диапазон значений на разных компиляторах может быть разным.
Например, для типа `int` на уровне стандарта гарантируется, что он должен занимать не менее 16 бит;
во всех распространённых компиляторах он занимает 32 бита.
То есть, хоть и в **большинстве** случаев `int` может хранить значение из диапазона примерно [-2 млрд; +2 млрд],
соответствущего размеру переменной в 32 бита,
стандартом **гарантируется** лишь диапазон примерно [-32 тысячи; +32 тысячи],
соответствующий размеру переменной в 16 бит.
Подробнее см. [C++ Reference: Fundamental types](https://en.cppreference.com/w/cpp/language/types).

При объявлении переменной примитивного типа без инициализации её начальное значение не определено,
то есть содержит произвольное "мусорное" значение.

Инициализация переменной может быть осуществлена следующим образом:
```
тип_переменной имя_переменной = начальное_значение;
```

Например:
```cpp
bool is_active = true;
int counter = 0;
```

⚠ Никогда не оставляйте переменную примитивного типа непроинициализированной (с "мусорным" значением)!
См. норму [ES.20: Always initialize an object](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es20-always-initialize-an-object).
Несмотря на кажущуюся сложность, инициализацию можно провести всегда в момент объявления переменной:
- если значение переменной неизвестно на момент объявления, объявите её позже (см. также
  [ES.5: Keep scopes small](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es5-keep-scopes-small),
  [ES.21: Don’t introduce a variable (or constant) before you need to use it](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it)
  и
  [ES.22: Don’t declare a variable until you have a value to initialize it with](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with));
- если значение переменной инициализируется в зависимости от условия `if`, используйте тернарную форму оператора;
- если значение переменной инициализируется более сложным образом,
  вычисление начального значения всегда можно вынести в отдельную функцию
  (или использовать анонимную функцию - см. [* ES.28: Use lambdas for complex initialization, especially of const variables](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es28-use-lambdas-for-complex-initialization-especially-of-const-variables);
  здесь и далее звездочкой помечены факультативные нормы, которые выходят за рамки текущего курса).

См. также следующие нормы касаемо переменных и их именования:
- [ES.6: Declare names in for-statement initializers and conditions to limit scope](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope)
- [ES.7: Keep common and local names short, and keep uncommon and non-local names longer](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer)
- [ES.8: Avoid similar-looking names](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es8-avoid-similar-looking-names)
- [ES.9: Avoid ALL_CAPS names](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es9-avoid-all_caps-names)
- [ES.12: Do not reuse names in nested scopes](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es12-do-not-reuse-names-in-nested-scopes)



## 1.2 Действия над данными

### 1.2.1 Управляющие конструкции языка

Синтаксис объявления/определения функций, условного оператора и циклов в C корректен и в С++.
Кроме того, в C++ имеются некоторые дополнительные возможности: например,
возможность передачи параметра по ссылке и специальная форма цикла `for`.
Подробнее о них будет рассказано на лекциях, в первой лабораторной эти возможности не понадобятся.



### 1.2.2 Операторы

Операторы делятся на:
- унарные (один операнд), например, оператор отрицания `!`:
  ```cpp
  bool is_active = true;
  bool is_inactive = !is_active; // один операнд: переменная is_active
  ```
- бинарные (два операнда), например, оператор умножения `*`:
  ```cpp
  int unit_price_per_g = 5;
  int weight_g = 1500;
  int total_price = unit_price_per_g * weight_g; // два операнда: переменные unit_price_per_g и weight_g
  ```
- существуют операторы больше чем с двумя операндами, вот некоторые из них:
  - тернарный условный оператор `a ? b : c` (три операнда);
  - оператор вызова функции `f(a1, a2)` (в общем случае произвольное количество операндов:
    один операнд - это название функции; остальные операнды - это аргументы функции).

Отметим, что любой оператор идейно можно свести к оператору вызова функции, как самому обобщённому.
Наличие операторов, отличных от оператора вызова функции, обусловлено лишь удобством представления.

  - Гипотетически предположим, что операции сложения и умножения в языке предоставлялись бы функциями `sum` и `product`.
    Для сравнения удобочитаемости посмотрите на эквивалентные представления одного и того же выражения:
    - с помощью функций:
      ```cpp
      int result = product(a, sum(b, product(sum(c, d), e)));
      ```
    - с помощью операторов:
      ```cpp
      int result = a * (b + (c + d) * e);
      ```
    Очевидно, что второй способ является куда более наглядным и читабельным.



## 1.3 Заголовочные файлы

Полный список заголовочных файлов стандартной библиотеки C++ можно посмотреть здесь:
[C++ Standard Library headers](https://en.cppreference.com/w/cpp/header).

В рамках нашего курса изучается весьма ограниченное подмножество стандартной библиотеки.
Необходимые для включения заголовочные файлы будут изучаться по мере надобности.

На данный момент отметим несколько фактов, касающихся стандартных заголовочных файлов языка C.
1. Все заголовочные файлы, которые были доступны в C, доступны и в C++.
1. Однако из название изменено: если в C файл назывался `name.h`, то в C++ он называется `cname`.
   - Например, для использования `printf`/`scanf` в C:
     ```c
     #include <stdio.h>
     ```
     В C++:
     ```cpp
     #include <cstdio>
     ```

⚠ Несмотря на то, что весь функционал С доступен в C++ (см. предыдущий пункт),
категорически не рекомендуется использовать какие бы то ни было заголовочные файлы стандартной библиотеки С.
Как правило, для любого заголовочного файла C в C++ существуют более высокоуровневые и безопасные альтернативы.
См. норму [CPL.1: Prefer C++ to C](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cpl1-prefer-c-to-c).
Например:
- для работы со строками вместо `cstring` лучше использовать `string` (будет рассмотрен далее);
- для ввода-вывода вместо `cstdio` лучше использовать `iostream` (будет рассмотрен далее);
- исключение из правила - `cmath` (альтернативы нет; при необходимости можно включать этот файл библиотеки C).



## 1.4 Пространства имён

Пространство имен - это область определения различных идентификаторов (имён типов, функций, переменных, и т. д.).
Пространства имен используются для организации кода в виде логических групп и с целью избежания конфликтов имен.

- Можно провести аналогию с файловой системой (ФС).
  - В C нет пространств имён (можно сказать, что существует только одно, глобальное, пространство имён).
    - Все функции находятся в глобальной области видимости. Аналогия в ФС: все файлы находятся в одной директории.
    - Вы не можете создать две функции с одинаковым именем. Аналогия в ФС: нельзя создать два файла с одним именем в пределах одной директории.
  - В C++ есть пространства имён.
    - Функции можно разложить по разным пространствам имён (в том числе вложенным). Аналогия в ФС: файлы можно разложить по разным директориям (в том числе вложенным).
    - Можно объявить две функции с одинаковым именем, если они расположены в разных пространствах имён. Аналогия в ФС: можно создать два файла с одинаковым именем, при условии, что они будут располагаться в разных директориях.

Пример объявления функций внутри пространства имён:
```cpp
namespace my_namespace {
  void f();
  void g();
}
```

Пример определения функции, объявленной внутри пространства имён:
```cpp
void my_namespace::f() {
  ...
}
```

Пример вызова функции, объявленной внутри пространства имён, с использованием её полного имени:
```cpp
my_namespace::f();
```

Чтобы при вызове не указывать каждый раз пространство имён, можно использовать директиву `using [namespace]`:
- Для импорта конкретного идентификатора в текущую область видимости:
  ```cpp
  {
    using my_namespace::f;

    f();               // Вызов my_namespace::f
    my_namespace::g(); // Для вызова g нужно по-прежнему указывать полное имя
  }
  ```
- Для импорта всех идентификаторов из пространства имён в текущую область видимости:
  ```cpp
  {
    using namespace my_namespace;

    f();
    g();
  }
  ```

Импортировать можно не только в текущую область видимости (функции или вложенного блока),
но и в область видимости всего текущего файла исходного кода.
Для этого директиву `using [namespace]` располагают в начале файла,
сразу после `#include` но до начала определений каких-либо функций.


⚠ Директива `using [namespace]` должна использоваться только в файлах исходного кода,
её не следует применять в заголовочных файлах (в заголовочных файлах используйте полные имена).
- Попробуйте догадаться сами - почему?

Нормы:
- [SF.6: Use using namespace directives for transition, for foundation libraries (such as std), or within a local scope (only)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only)
- [SF.7: Don’t write using namespace at global scope in a header file](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file)



## 1.5 Классы и объекты

Напомним, что **структура** - составной тип данных, состоящий из полей.

В C++ появляется принципиально новый тип данных, называемый **классом**.

Конкретные переменные этого типа данных (класса) называются **объектами**.

Класс, в отличие от структуры, имеет не только состояние (набор полей),
но и набор определённых действий (методы), которые можно выполнить у объектов данного класса.
Методы представляют из себя функции специального вида с особым синтаксисом вызова.

Написание собственных классов - тема следующей лабораторной работы.

В рамках текущей работы рассмотрим пример использования класса `std::string` из стандартной библиотеки C++
(заголовочный файл `string`), предназначенного для работы со строками.
Напомним, что в C для работы со строками вы использовали указатель `char*`.
В C++ для работы со строками предпочтительно использовать тип `std::string`.

```cpp
#include <string>

using namespace std;

int main() {
  string s = "Hello, world!";

  size_t length = s.size();
  string sub = s.substr(0, 5);

  return 0;
}
```

Поясним:
- В первой строке заводится объект (переменная) `s` типа `std::string` и инициализируется значением `Hello, world!`.
  ```cpp
  string s = "Hello, world!";
  ```
- Далее у объекта `s` вызывается метод `size`, который возвращает размер строки (в данном случае это будет 13).
  ```cpp
  size_t length = s.size();
  ```
  Обратите внимание на особенности вызова метода.
  - Обращение к методу происходит также, как и к полю у структуры:
    после имени объекта ставится `.`, затем указывается имя метода.
  - Метод необходимо **вызвать**, поэтому обязательно ставятся круглые скобки.
    В данном случае метод не имеет параметров, поэтому скобки пустые.
    Если круглые скобки были бы опущены (`s.size`), то для компилятора это означало бы обращение к полю `size`,
    а не вызов метода - и это привело бы к ошибке компиляции
    (т. к. у класса `string` поля с именем `size` нет, есть только метод с таким именем).
  - Метод можно вызвать, только если есть объект. Без объекта вызвать метод нельзя.
    - Аналогия: к полю некоторой структуры `S` вы можете обратиться, только если у вас есть переменная `s` типа `S`.
- Далее у объекта `s` вызывается метод вычисления подстроки `substr`,
  результат работы которого сохраняется в новый объект (переменную) `sub` типа `std::string`.
  ```cpp
  string sub = s.substr(0, 5);
  ```
  Метод `substr` имеет два параметра (первый задаёт индекс начала подстроки; второй - длину подстроки).
  В результате объект `sub` будет содержать значение `Hello`.

Список доступных методов определяется классом (типом) объекта.
Документацию по `std::string` (включая список всех доступных методов) см. здесь:
[C++ Reference: std::basic_string](https://en.cppreference.com/w/cpp/string/basic_string).



## 1.6 Ввод-вывод с помощью стандартной библиотеки C++

### 1.6.1 Заголовочный файл `<iostream>`

Заголовочный файл `iostream` предоставляет доступ к классам (типам данных) `std::istream` и `std::ostream`,
с помощью которых осуществляется ввод-вывод данных.

Кроме того, в заголовочном файле `iostream` определены глобальные объекты:
- `std::cin` - стандартый поток ввода (объект типа `std::istream`);
- `std::cout` и `std::cerr` - стандартные потоки вывода и ошибки (объекты типа `std::ostream`).

Внутри эти глобальные объекты используют стандартные потоки ввода-вывода C
(`std::cin` - `stdin`; `std::cout` - `stdout`, `std::cerr` - `stderr`).

Вывод данных осуществляется с помощью бинарного оператора `<<`.
В качестве левого операнда указывается объект типа `std::ostream`, в качестве правого - значение для вывода.
Для вывода значения с помощью оператора `<<` должна существовать перегрузка оператора,
которая в качестве второго операнда принимает поддерживаемый тип данных.
Как правило, для стандартных типов (примитивные типы, `std::string`) такая перегрузка предоставляется стандартной библиотекой.
Для вывода собственных типов данных понадобится предоставить собственную перегрузку.
Синтаксис предоставления собственной перегрузки будет изучен в последующих лабораторных работах.

Пример вывода значения переменной с помощью стандартного потока вывода:
```cpp
#include <iostream>

using namespace std;

int main() {
  int a = 42;
  cout << a;
  return 0;
}
```

Обратим внимание, что в подсистеме ввода-вывода результатом вычисления оператора `<<` является первый операнд
(объект типа `std::ostream`). Это позволяет объединять вывод в "цепочку":
```cpp
int a = 13;
int b = 42;
cout << a << " " << b; // Предпочтительный вариант вывода
```

Последняя строка эквивалентна следующим двум вариантам:
```cpp
// Альтернативный вариант с явным определением порядка вычисления:
((cout << a) << " ") << b;

// Альтернативный вариант, где операторы явно вызываются как методы у объекта cout:
cout.operator<<(a).operator<<(b).operator<<(c); 
```

Ввод данных осуществляется аналогичным образом, только используется оператор `>>`
(направление стрелок в другую сторону), где в качестве первого операнда должен выступать объект типа `std::istream`.

Пример ввода значения с помощью стандартного потока ввода:
```cpp
#include <iostream>

using namespace std;

int main() {
  int a = 0;
  cin >> a;
  return 0;
}
```

При вводе нескольких переменных сразу можно использовать "цепочку" (всё так же, как и при выводе).

Нормы:
- [SL.io.3: Prefer iostreams for I/O](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio3-prefer-iostreams-for-io)
- [* SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio10-unless-you-use-printf-family-functions-call-ios_basesync_with_stdiofalse).



### 1.6.2 Форматированный вывод: заголовочный файл `<iomanip>`

Заголовочный файл `<iomanip>` содержит манипуляторы - вспомогательные функции или объекты.
Такие объекты (или результат работы функции в случае функции) могут быть направлены
в потоки вывода с целью форматирования вывода определённым образом.

**Вывод вещественных чисел**

- `std::fixed`. Задаёт формат вывода вещественных чисел в виде целой и дробной части.
- `std::scientific`. Задаёт формат вывода вещественных чисел в экспоненциальном (т. н. научном) виде.
- `std::setprecision(int n)`. Задаёт количество знаков в дробной части.

**Выравнивание**

- `std::setw(int n)`. Задаёт ширину (в символах) следующей операции вывода.
- `std::setfill(char c)`. Задаёт символ, который будет использоваться в качестве заполнителя,
  чтобы обеспечить заданную ширину вывода.
- `std::left` или `std::right`. Задают выравнивание вывода в пределах заданной ширины.

**Разное**

- `std::endl`. Символ конца строки (переход на новую строку).
  В отличие от многих других манипуляторов, которые лишь изменяют состояние потока,
  но сами по себе не выводят какие-либо данные,
  этот манипулятор выводит в поток символ конца строки (`\n`) и принудительно сбрасывает буфер вывода.
  В общем случае не рекомендуется к использованию - см.
  [* SL.io.50: Avoid endl](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio50-avoid-endl).

**Пример**

```cpp
#include <iomanip>
#include <iostream>

using namespace std;

int main() {
  cout << fixed << setprecision(2);
  cout << 1.234 << " " << 2.345 << endl;    // 1.23 2.35
  
  cout << setfill('*');
  cout << setw(9) << right << "hi" << endl; // *******hi
  cout << setw(9) << left << "hi" << endl;  // hi*******
}
```

Подробнее про манипуляторы см. [C++ Reference: Input/output manipulators](https://en.cppreference.com/w/cpp/io/manip/fixed).



### 1.6.3 Форматированный вывод: заголовочный файл `<format>`

Альтернативой манипулятором ввода-вывода является использование заголовочного файла `<format>`.

Для использования `<format>` вам понадобится относительно новая версия компилятора, поддерживающая стандарт C++20.
- В первую очередь, убедитесь, что у вас подходящая версия компилятора.
  Например, Debian на данный момент поставляется с GCC версии 12, тогда как для C++20 требуется версия 13.
  Проверьте вашу версию компилятора (`g++ --version`).
  Если у вас неподходящая версия компилятора, используйте манипуляторы ввода-вывода из `<iomanip>`.
- Если версия компилятора поддерживает C++20, укажите в файле сценария `CMakeLists.txt` требуемую версию стандарта
  (после `project`, но до `add_executable`):
  ```
  set(CMAKE_CXX_STANDARD 20)
  ```

Данный заголовочный файл предоставляет функцию `std::format`,
позволяющая получить строковое представление (`std::string`) в нужном формате.
Данную функцию можно рассматривать как безопасную альтернативу функции `sprintf` из C.

В качестве первого параметра функция принимает строку форматирования (шаблон),
которая может содержать произвольное количество плейсхолдеров `{}`.
Второй и последующие параметры задают значения, которые должны подставляться вместо указанных плейсхолдеров.

Пример:
```cpp
#include <format>
#include <iostream>
#include <string>

using namespace std;

int main() {
  int a = 3;
  int b = 7;

  string s = format("{} + {} = {}\n", a, b, a + b);
  cout << s;
  
  // Можно проще, без временной переменной:
  // cout << format("{} + {} = {}\n", a, b, a + b);
}
```

Вывод будет выглядеть следующим образом:
```
3 + 7 = 10
```

Рассмотрим некоторые опции форматирования, которые могут применяться к плейсхолдерам:

- Задание минимальной ширины:
  ```
  {:ширина_в_символах}
  ```
- Выравнивание в пределах заданной минимальной ширины:
  ```
  {:<ширина_в_символах}
  ```
  где вместо `<` может стоять один из следующих знаков:
  - `<` - выравнивание по левому краю;
  - `^` - выравнивание по центру;
  - `>` - выравнивание по правому краю.
- Вывод вещественного числа в виде целой и дробной части с указанием количества знаков дробной части:
  ```
  {:.2f}
  ```
  Здесь вместо 2 может стоять любое число, задающее количество знаков дробной части.
- Переопределение порядка аргументов.
  По умолчанию аргументы подставляются в шаблон в порядке следования.
  Это поведение можно переопределить, указав в фигурных скобках до двоеточия индекс аргумента:

  ```cpp
  #include <format>
  #include <iostream>
  
  using namespace std;
  
  int main() {
    int a = 10;
    int b = 20;
    int c = 30;
    cout << format("{2:} {1:} {0:}", a, b, c);
  }
  ```
  Вывод:
  ```cpp
  30 20 10
  ```
  Явное указание индексов аргументов может быть полезным, когда нужно вывести один и тот же аргумент несколько раз.

Подробнее про `format` см. [C++ Reference: Standard format specification](https://en.cppreference.com/w/cpp/utility/format/spec).



## 1.7 Пример

Пример программы, которая считывает два целых числа и выводит их сумму:
```cpp
#include <iostream>

using namespace std;

int main() {
  cout << "Enter the first number: ";
  int first_number = 0;
  cin >> first_number;
  
  cout << "Enter the second number: ";
  int second_number = 0;
  cin >> second_number;
  
  int sum = first_number + second_number;
  
  cout << "Sum: " << sum << "\n";
  
  return 0;
}
```



# 2 Обязательное задание

Для данной и всех последующих лабораторных работ:
- номер варианта назначается преподаваталем;
- для сборки проекта должен использоваться CMake (см. [Подготовка к выполнению лабораторных работ](lab0-preparation.md)).



## 2.1 Общее задание
- Реализовать алгоритм согласно варианту.
- **Алгоритм должен быть однопроходным: последовательность чисел не должна храниться в памяти**.
  - Каждый новый элемент вводится и обрабатывается в соответствии с алгоритмом на очередной итерации цикла.
  - Запрещено использовать любые массивы, указатели и т. п.
- Количество элементов в последовательности задаётся пользователем.
- Элементы последовательности считать целыми числами (использовать тип `int`).



## 2.2 Варианты

1. Посчитать сумму элементов последовательности.
1. Посчитать произведение элементов последовательности.
1. Найти наименьший элемент в последовательности.
1. Найти наибольший элемент в последовательности.
1. Посчитать среднее арифметическое элементов последовательности.
1. Найти сумму квадратов элементов последовательности.
1. Найти сумму кубов элементов последовательности.
1. Посчитать сумму четных элементов последовательности.
1. Посчитать сумму нечетных элементов последовательности.
1. Посчитать произведение четных элементов последовательности.
1. Посчитать произведение нечетных элементов последовательности.
1. Проверить, является ли последовательность возрастающей.
1. Проверить, является ли последовательность убывающей.
1. Проверить, является ли последовательность невозрастающей.
1. Проверить, является ли последовательность неубывающей.
1. Проверить, являются ли все элементы последовательности положительными.
1. Проверить, являются ли все элементы последовательности отрицательными.
1. Проверить, являются ли все элементы последовательности неположительными.
1. Проверить, являются ли все элементы последовательности неотрицательными.
1. Проверить, являются ли все элементы последовательности четными.
1. Проверить, являются ли все элементы последовательности нечетными.
1. Найти сумму наибольшего и наименьшего чисел последовательности.
1. Найти произведение наибольшего и наименьшего чисел последовательности.
1. Посчитать количество положительных элементов последовательности.
1. Посчитать количество отрицательных элементов последовательности.
1. Посчитать количество элементов последовательности, меньших данного числа.
1. Пользователь задает натуральное число. Посчитать количество элементов последовательности, больших заданного числа.
1. Пользователь задает натуральное число. Посчитать количество элементов последовательности, делящихся на заданное число без остатка.
1. Пользователь задает натуральное число. Посчитать сумму элементов последовательности, меньших заданного числа.
1. Пользователь задает натуральное число. Посчитать сумму остатков от деления элементов последовательности на заданное число.



## 2.3 Нормы

- [CPL.1: Prefer C++ to C](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cpl1-prefer-c-to-c)
- [ES.5: Keep scopes small](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es5-keep-scopes-small)
- [ES.6: Declare names in for-statement initializers and conditions to limit scope](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope)
- [ES.7: Keep common and local names short, and keep uncommon and non-local names longer](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer)
- [ES.8: Avoid similar-looking names](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es8-avoid-similar-looking-names)
- [ES.9: Avoid ALL_CAPS names](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es9-avoid-all_caps-names)
- [ES.12: Do not reuse names in nested scopes](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es12-do-not-reuse-names-in-nested-scopes)
- [ES.20: Always initialize an object](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es20-always-initialize-an-object)
- [ES.21: Don’t introduce a variable (or constant) before you need to use it](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it)
- [ES.22: Don’t declare a variable until you have a value to initialize it with](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with)
- [ES.26: Don’t use a variable for two unrelated purposes](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es26-dont-use-a-variable-for-two-unrelated-purposes)
- [* ES.28: Use lambdas for complex initialization, especially of const variables](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es28-use-lambdas-for-complex-initialization-especially-of-const-variables)
- [NL.8: Use a consistent naming style](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#nl8-use-a-consistent-naming-style)
  - В рамках данного курса рекомендуется использовать
    [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
- [SF.6: Use using namespace directives for transition, for foundation libraries (such as std), or within a local scope (only)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only)
- [SF.7: Don’t write using namespace at global scope in a header file](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file)
- [SL.io.3: Prefer iostreams for I/O](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio3-prefer-iostreams-for-io)
- [* SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio10-unless-you-use-printf-family-functions-call-ios_basesync_with_stdiofalse).
- [* SL.io.50: Avoid endl](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio50-avoid-endl)

Звездочкой помечены факультативные нормы, которые выходят за рамки текущего курса.



## 2.4 Пример

Пользователь задаёт натуральное число. Проверить, содержится ли данное число в последовательности.

```cpp
#include <iostream>

using namespace std;

int main() {
  ios_base::sync_with_stdio(false);

  cout << "Enter a number to find: ";
  int number = 0;
  cin >> number;

  cout << "Enter an array size: ";
  int size = 0;
  cin >> size;

  cout << "Enter elements of the array: ";
  bool found = false;
  for (int i = 0; i < size; ++i) {
    int item = 0;
    cin >> item;
    if (item == number) {
      found = true;
    }
  }

  cout << "Is the number present in the array? " << (found ? "YES\n" : "NO\n");

  return 0;
}
```

Пример ввода-вывода:
```
Enter a number to find: 12
Enter an array size: 3
Enter elements of the array: 1 2 3
Is the number present in the array: NO
```



# 3 Факультативное задание

1. Продемонстрировать сборку и запуск вашего проекта в командной строке без использования среды разработки следующими двумя способами:
   - без использования системы сборки (использовать компилятор напрямую);
   - с использованием `cmake` и системы сборки.
2. Продемонстрировать сборку и запуск вашего проекта в командной строке без использования среды разработки на виртуальной машине с Linux следующими двумя способами:
   - без использования системы сборки (использовать компилятор `g++` напрямую);
   - с использованием `cmake` и системы сборки.
   
   Для выполнения этого пункта вам понадобится виртуальная машина с любым установленным дистрибутивом Linux.
   Для создания виртуальной машины и установки операционной системы можно воспользоваться:
   - инструкцией [Установка Debian на виртуальную машину UTM или VirtualBox](extra-debian.md);
   - любым руководством из интернета на ваше усмотрение.
