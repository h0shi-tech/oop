# Задача № 4
# Параллельное умножение матриц

## Срок сдачи

До 31 марта включительно.



## Задание

1. Доработать код по умножению матриц с практики по `std::thread`.
   - Перегрузить операторы сравнения двух матриц `==` и `!=`.
     Сравнение каждого элемента должно происходить с некоторой точностью `e = 0.001`.
     Если разность двух элементов матрицы по модулю меньше `e`, то считать такие элементы равными.
   - Написать функцию `random_fill` по случайному заполнению матрицы вещественными значениями от 0 до 1
     и инициализировать входные матрицы `m1` и `m2` в `main` с помощью этой функции.
     Должен использоваться `std::default_random_engine` и `std::uniform_real_distribution<float>`.
   - Улучшить `multiply_v2`, убрав требование делимости без остатка количества строк (в результирующей матрице)
     на количество потоков.
     - Количество потоков сделать параметром функции.
       Предусмотреть значение по умолчанию, равное нулю.
       При нулевом значении должно использоваться значение
       [hardware_concurrency](https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency).
       Если `hardware_concurrency` возращает 0, откатываться к значению 1.
       Если количество потоков равно 1, допустимо синхронно вызвать `multiply_v1`, не создавая новых потоков вообще.
     - Случай, когда количество строк меньше, чем количество потоков, должен обрабатываться корректно.
   - С учётом вышенаписанных оператора `==` и функции `random_fill` убедиться в `main`,
     что умножение ненулевых матриц с помощью `multiply_v1` и `multiply_v2` даёт один и тот же результат.
   - В `main` замерить и вывести в консоль время работы `multiply_v1` и `multiply_v2`.
     См. [Measure execution time of a function in C++](https://www.geeksforgeeks.org/measure-execution-time-function-cpp/).
     Подсказка (опционально). Используя вышеприведённую статью, упростите замер времени в `main`,
     описав вспомогательный класс `Timer`. В конструкторе запоминается текущее время,
     в деструкторе вычисляется и выводится в консоль разница между текущим временем и запомненным.
   - Отрефакторить файловую структуру проекта.
     Проект должен состоять из следующих файлов:
     - `matrix.h` - объявление класса `Matrix` и вспомогательных функций
       (оператор вывода, операторы `==` и `!=`, `fill_random`);
     - `matrix.cpp` - определение методов `Matrix` и вспомогательных функций;
     - `multiply.h` - объявления функций `multiply_v1` и `multiply_v2`;
     - `multiply.cpp` - определение (совмещённое с объявлением) функции `row_x_col`,
       определения функций `multiply_v1` и `multiply_v2`;
     - `main.cpp`.

     Обратите внимание, что при использовании параметров со значениями по умолчанию,
     сами значения по умолчанию должны указываться только при объявлении функции,
     но не должны указываться при определении.

2. Реализовать параллельный алгоритм (`multiply_v3`) с распределением нагрузки между потоками "на лету".
   - Каждый поток должен работать по следующему алгоритму.
     Внутри вечного цикла:
     - Критическая секция: получить значения очередных координат элемента выходной матрицы
       и сдвинуть эти координаты на следующий элемент.
       Если координаты уже вышли за пределы матрицы (обработаны все элементы), то координаты не менять.
       - Примечание. Элементы матрицы должны обходиться построчно.
         Так, для матрицы `2x3` значения очередных координат
         по мере работы потоков должны принимать следующие значения:
         `(0,0)`, `(0,1)`, `(0,2)`, `(1,0)`, `(1,1)`, `(1,2)`, `(1,3)` **или** `(2,0)`.
     - Вне критической секции:
       - если координаты элемента выходной матрицы для расчёта выходят за пределы (т. е. обработаны все элементы),
         то завершить работу потока (выйти из цикла);
       - иначе рассчитать элемент выходной матрицы по полученным координатам и
         перейти на следующую итерацию вечного цикла.

     Подсказка (опционально).
     Допускается вынести критическую секцию в отдельно обособленный метод `get_next` специального класса.
     Можно также избежать использования координат, выходящих за пределы матрицы
     (в примере выше - `(1,3)` или `(2,0)`). 
     Если пара координат задаётся типом `Point`, то `get_next` может возвращать тип `std::optional<Point>`
     (см. [std::optional](https://en.cppreference.com/w/cpp/utility/optional)).
     В этом случае, когда обработаны все элементы матрицы, `get_next` вернёт не координаты,
     выходящие за пределы матрицы, а специальное значение `std::nullopt`.
   - Добавить объявление/определение `multiply_v3` в `multiply.h`/`multiply.cpp`.
   - Добавить вызов `multiply_v3` в `main` и аналогично другим функциям умножения:
     - обеспечить замер и вывод времени работы;
     - убедиться в эквивалентности результатов работы всех трёх функций (`multiply_v1`, `multiply_v2` и `multiply_v3`).
