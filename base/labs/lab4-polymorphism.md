
# Лабораторная работа № 4 <!-- omit in toc -->
# Полиморфные классы <!-- omit in toc -->

- [1 Теоретические сведения](#1-теоретические-сведения)
  - [1.1 Наследование](#11-наследование)
  - [1.2 Умные указатели и приведение типов](#12-умные-указатели-и-приведение-типов)
  - [1.3 Пример наследования в стандартной библиотеке](#13-пример-наследования-в-стандартной-библиотеке)
  - [1.4 Формальный и фактический типы](#14-формальный-и-фактический-типы)
  - [1.5 Перекрытие методов и раннее связывание](#15-перекрытие-методов-и-раннее-связывание)
  - [1.6 Переопределение методов и позднее связывание](#16-переопределение-методов-и-позднее-связывание)
  - [1.7 Абстрактные классы и интерфейсы](#17-абстрактные-классы-и-интерфейсы)
  - [1.8 Пример](#18-пример)
- [2 Обязательное задание](#2-обязательное-задание)
  - [2.1 Общее задание](#21-общее-задание)
  - [2.2 Варианты](#22-варианты)
  - [2.3 Нормы](#23-нормы)
- [3 Факультативное задание](#3-факультативное-задание)

# 1 Теоретические сведения

## 1.1 Наследование

Наследование позволяет определять новый тип, расширяя уже существующий.

Предположим, есть класс `Person`, позволяющий хранить имя, фамилию и дату рождения:

```cpp
#include <chrono>
#include <iostream>

using namespace std;
using namespace std::chrono;

class Person {
  string _first_name;
  string _last_name;
  year_month_day _birthdate;

public:
  Person(const string& first_name, const string& last_name, const year_month_day& birthdate) :
    _first_name(first_name), _last_name(last_name), _birthdate(birthdate) { }

  const string& first_name() const noexcept {
    return _first_name;
  }

  const string& last_name() const noexcept {
    return _last_name;
  }

  const year_month_day& birthdate() const noexcept {
    return _birthdate;
  }

  Person(const Person&) = delete;            // Объяснения см. в нормах
  Person& operator=(const Person&) = delete; // Объяснения см. в нормах
  virtual ~Person() = default;               // Объяснения см. в нормах
};
```

Предположим, необходимо определить класс студента `Student`.
При этом студент определяется не только теми атрибутами, которые есть у любого человека
(т. е. именем, фамилией, датой рождения - всем тем, что есть у `Person`),
но и некоторыми специфичными данными - например, номером зачётной книжки `student_id`.
Тогда новый класс `Student` можно определить как **наследник** класса `Person`:

```cpp
class Student : public Person {
  string _student_id;

public:
  Student(
    const string& first_name,
    const string& last_name,
    const year_month_day& birthdate,
    const string& student_id
  ) :
    Person(first_name, last_name, birthdate),
    _student_id(student_id)
  { }

  const string& student_id() const noexcept {
    return _student_id;
  }
};
```

При этом класс `Student` получит все то, что есть у класса `Person`,
в частности, публичные методы `first_name`, `last_name`, `birthdate`.
Приватные поля тоже унаследуется, но прямого доступа к ним не будет.

Здесь возникает смысл в третьем модификаторе доступа `protected`:
- `private` - доступ есть только у самого класса;
- `protected` - доступ есть только у самого класса и его наследников;
- `public` - доступ есть у всех.

Обратим внимание, что при наследовании тоже указывается модификатор:
```cpp
class Student : public Person {
  // ...
};
```

В данном контексте `public` означает вид наследования.
Если кратко, то этот модификатор задаёт максимально допустимую область видимости унаследованных членов для внешнего кода.
- `public` оставляет область видимости неизменной;
- `private`, например, сделал бы все унаследованные `protected` и `public`-члены закрытыми.

В рамках нашего курса всегда будет использоваться только открытое (`public`) наследование,
как самое распространённое и основное.
Остальные виды наследования имеют достаточно узкий круг применения и выходят за рамки нашего курса.

При создании объекта порядок вызова конструкторов - сверху вниз (от базового класса к дочернему).
Если для инициализации базового класса необходимо использовать конструктор с параметрами,
то необходимый конструктор должен вызываться в списке инициализации (см. конструктор `Student` в примере выше).
При уничтожении объекта порядок вызова деструкторов обратен порядку вызова конструкторов,
то есть деструктора вызываются снизу вверх (от дочернего класса к базовому).

**Обратим внимание, что основной причиной применения наследования является не избежание дублирования кода
(полей и методов класса), а моделирование отношения "является" (студент является человеком).
Устранение дублирования здесь является лишь побочным эффектом.**

Это позволяет писать абстрактный код, работающий на уровне базового класса,
и ничего не знающий о реальном типе объекта:

```cpp
// ...

void print(const Person& p) {
  cout << p.birthdate() << ' ' << p.last_name() << ' ' << p.first_name() << ' ' << '\n';
}

int main() {
  Person p("Gina", "Rayo", year_month_day(1957y, June, 15d));
  Student s("Alfred ", "Parker", year_month_day(1980y, December, 13d), "123-456-789");
    
  print(p);
  print(s);
}
```

Обратите внимание, что `print` принимает параметр типа `Person`.
Но так как `Student` является наследником `Person`, 
то в качестве аргумента функции `print` можно указать студента (объект типа `Student`).
При этом сама функция `print` оперирует с объектом на уровне базового класса (`Person`),
ничего не зная о реальном типе (`Person` или `Student`).

Таким образом, функции `print` можно в качестве аргумента передать объект любого типа,
являющегося наследником от типа `Person`.

Отметим, что наследование позволяет реализовать динамический полиморфизм
(полиморфизм времени выполнения), когда один и тот же код (в примере выше - тело функции `print`)
**во время выполнения программы** (а не во время компиляции, как в случае с шаблонами)
может работать с различными типами данных (в примере выше - `Person` и `Student`).

**⚠ Обратим внимание, что при работе с иерархией классов принципиально важно
передавать базовый класс по ссылке или через указатель, но не по значению.**
В противном случае может произойти так называемая
[срезка](https://www.geeksforgeeks.org/object-slicing-in-c/)
объекта, которая является одной из ошибок программирования на C++.

Нормы:
- [C.133: Avoid protected data](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c133-avoid-protected-data)
- [C.145: Access polymorphic objects through pointers and references](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c145-access-polymorphic-objects-through-pointers-and-references)
- [C.152: Never assign a pointer to an array of derived class objects to a pointer to its base](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base)



## 1.2 Умные указатели и приведение типов

При необходимости работы со статическими/динамическими массивами
используются шаблонные классы `std::array`/`std::vector`.

Но что, если необходимо завести указатель на **один** объект?

Для этого используются **умные указатели** - шаблонные классы
[`std::shared_ptr`](https://en.cppreference.com/w/cpp/memory/shared_ptr) (разделяемое владение)
и
[`std::unique_ptr`](https://en.cppreference.com/w/cpp/memory/unique_ptr) (исключительное владение)
из заголовочного файла `<memory>`.
Данные шаблонные классы автоматически (за счёт деструктора) освобождают память, когда объект становится никому не нужным.
Данные классы перегружают операторы разыменовки `*`, `->` и операторы сравнения с `nullptr` -
таким образом, с объектами этих классов можно работать так, как будто бы это обычные указатели.

```cpp
#include <iostream>
#include <memory>

using namespace std;

struct T {
  T(int a, int b) { }
};

int main() {
  // Пример использования shared_ptr (разделяемое владение со счётчиком)
  {
    shared_ptr<T> sp1 = make_shared<T>(1, 2);

    // shared_ptr является копируемым:
    shared_ptr<T> sp2(sp1);

    // Здесь sp1 и sp2 указывают на один и тот же объект,
    // при этом оба указателя являются полноправными владельцами.
    // Внутри используется счётчик ссылок,
    // текущее значение счётчика можно получить с помощью use_count.
    // Оператор delete для объекта вызовется, когда счётчик достигнет 0.
    cout << sp1.use_count() << '\n'; // Выведет 2
  } // Деструкторы sp1 и sp2 уменьшают счетчик до 0
    // и объект T удаляется из кучи последним отработавшим деструктором

  // Пример использования unique_ptr (исключительное владение)
  {
    unique_ptr<T> up1 = make_unique<T>(1, 2);

    cout << up1.get() << '\n';

    // unique_ptr скопировать нельзя, но владение можно "передать" с помощью std::move:
    unique_ptr<T> up2(move(up1));

    // Здесь up1 == nullptr, так как он передал ресурс, которым владеет, другому владельцу (up2).
    // Владельцем созданного объекта теперь является up2.

    cout << up1.get() << ' ' << up2.get() << '\n';
  } // Деструктор up2 удалит объект из кучи
}
```

При создании умных указателей желательно пользоваться не их конструкторами напрямую,
а использовать вспомогательные шаблонные функции `make_unique` и `make_shared` из заголовочного файла `<memory>`.
В качестве шаблонного аргумента указывается тип создаваемого объекта (в примере выше - `T`),
а в качестве аргументов - параметры нужного конструктора (в примере выше - два числа).

Приведение типа от дочернего класса к базовому (**upcasting**, "повышающее приведение", "абстрагирование") всегда выполняется автоматически и
является безопасным (т. к. дочерний класс всегда можно привести к базовому).

Обратная операция (**downcasting**, "понижающее приведение", "уточнение типа") является небезопасной
(базовый тип не всегда можно привести к указанному дочернему, ведь реальный тип может отличаться от указанного дочернего).
Для приведения базового типа к дочернему используется:
- для сырых указателей - синтаксическая конструкция `dynamic_cast`;
- для умных указателей - `std::dynamic_pointer_cast` из заголовочного файла `<memory>`.

**⚠ В грамотно спроектированном коде downcast использоваться не должен.**
- Необходимость в downcast-е говорит о плохо продуманном дизайне.
- В некоторых языках (OCaml) downcast запрещён в принципе.

Пример:

```cpp
#include <memory>

using namespace std;

struct A {
  A() = default;

  A(const A&) = delete;            // Объяснения см. в нормах
  A& operator=(const A&) = delete; // Объяснения см. в нормах
  virtual ~A() = default;          // Объяснения см. в нормах
};

struct B : public A {
};

int main() {
  // Приведение типов для сырых указателей
  {
    // ok (auto-upcast)
    A* ptr_a = new B();

    // bad (downcast): в случае неудачи вернёт nullptr
    B* ptr_b = dynamic_cast<B*>(ptr_a);

    // bad (downcast): в случае неудачи будет исключение типа std::bad_cast
    B& ref_b = dynamic_cast<B&>(*ptr_a);

    delete ptr_a;
  }

  // Приведение типов для умных указателей
  {
    // ok (auto-upcast)
    shared_ptr<A> ptr_a = make_unique<B>();

    // bad (downcast): в случае неудачи вернёт nullptr
    shared_ptr<B> ptr_b = dynamic_pointer_cast<B>(ptr_a);
  }
}
```

Нормы:
- [C.146: Use dynamic_cast where class hierarchy navigation is unavoidable](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable)
- [C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error)
- [C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative)
- [C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new)
- [R.22: Use make_shared() to make shared_ptrs](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r22-use-make_shared-to-make-shared_ptrs)
- [R.23: Use make_unique() to make unique_ptrs](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r23-use-make_unique-to-make-unique_ptrs)
- [* R.24: Use std::weak_ptr to break cycles of shared_ptrs](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs)



## 1.3 Пример наследования в стандартной библиотеке

Пусть есть следующий код:

```cpp
#include <iostream>

struct Point {
  float x { 0 };
  float y { 0 };
};

std::ostream& operator<<(std::ostream& stream, const Point& p) {
  stream << p.x << ' ' << p.y;
  return stream;
}
```

Тип `std::ostream` является базовым классом,
и под объектом `stream` на самом деле может скрываться не только тип `std::ostream`,
но и любой другой тип, унаследованный от него.

Рассмотрим на примере трёх разных типов.

**Во-первых, это может быть сам тип `std::ostream`** - например, стандартный поток вывода `std::cout`:
```cpp
#include <iostream>

// ... - определения Point и operator<<

int main() {
  Point p;

  // Первый вариант использования
  // Левый операнд оператора - объект типа std::ostream
  std::cout << p;
}
```

В стандартной библиотеке есть вспомогательный тип
[`std::iostream`](https://en.cppreference.com/w/cpp/io/basic_iostream),
который одновременно унаследован от двух типов - `std::istream` и `std::ostream`.
Это означает, что объекты типа `std::iostream` одновременно являются и потоками ввода, и потоками вывода -
то есть их можно передать везде, где в качестве параметра ожидается или `std::istream`, или `std::ostream`.
Рассматриваемые далее типы будут наследниками от `std::iostream`,
однако для простоты мы ограничимся демонстрацией только функционала, связанного с выводом (`std::ostream`).

**Во-вторых, это может быть тип
[`std::fstream`](https://en.cppreference.com/w/cpp/io/basic_fstream)**
(заголовочный файл `<fstream>`), унаследованный от `std::iostream`.
Этот тип является объектно-ориентированной альтернативой функциям Си по работе с файлами
(`fopen`, `fclose`, `fprintf`, `fwrite` и т. п.).
Пример распечатки объекта `p` в файл с названием `demo.txt`:
```cpp
#include <iostream>
#include <fstream>

// ... - определения Point и operator<<

int main() {
  Point p;

  // Второй вариант использования
  // Левый операнд оператора - объект типа std::fstream
  std::fstream fs("demo.txt", std::ios::out);
  fs << p;
}
```

**В-третьих, это может быть тип
[`std::stringstream`](https://en.cppreference.com/w/cpp/io/basic_stringstream)**
(заголовочный файл `<sstream>`), унаследованный от `std::iostream`.
Этот тип предназначен для распечатки данных в динамически расширяемый буфер в памяти,
который затем можно превратить в строку с помощью метода `str()`.
Пример получения строкового представления объекта:
```cpp
#include <iostream>
#include <sstream>

// ... - определения Point и operator<<

int main() {
  Point p;

  // Третий вариант использования
  // Левый операнд оператора - объект типа std::stringstream
  std::stringstream ss;
  ss << p;
  std::string s = ss.str();

  // С целью демонстрации распечатываем полученную строку в std::cout
  std::cout << s << '\n';
}
```

Разумеется, все перечисленные типы можно использовать одновременно.
Рассмотрим итоговый сквозной пример:
```cpp
#include <iostream>
#include <fstream>
#include <sstream>

struct Point {
  float x { 0 };
  float y { 0 };
};

std::ostream& operator<<(std::ostream& stream, const Point& p) {
  stream << p.x << ' ' << p.y;
  return stream;
}

int main() {
  Point p;

  // Раз...
  std::cout << p << '\n';

  // Два...
  {
    std::fstream fs("demo.txt", std::ios::out);
    fs << p;
  }

  // Три!
  std::stringstream ss;
  ss << p;
  std::string s = ss.str();
  std::cout << s;
}
```

**Обратите внимание на всю мощь наследования**.
Разработчик класса определил всего лишь **один оператор вывода**.
Однако пользователь класса может использовать этот **единственный оператор** для **совершенно разных задач**:
распечатки в стандартный поток вывода (раз), распечатки в файл (два) и получения строкового представления (три).

Более того, пользователь не ограничен вышеприведёнными сценариями.
Ничто не мешает реализовать собственного наследника
(или подключить стороннюю библиотеку с уже реализованным наследником)
с нужным вам поведением, который будет направлять получаемые данные в нужный приёмник.
Например, библиотека `boost` предоставляет наследник
[`boost::asio::ip::tcp::iostream`](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio/reference/ip__tcp/iostream.html),
который отправляет/принимает данные по сети (заинтересовавшиеся могут почитать
[официальные туториалы](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio/tutorial.html)).

Обратите внимание на **динамический полиморфизм** - у нас есть **один и тот же код**
(это тело перегруженного оператора `<<` - этот код один и тот же даже во время выполнения),
работающий с разными типами данных - в качестве левого операнда оператора
может выступать как сам тип `std::ostream`, так и любой его наследник.
При этом на момент объявления и определения оператора разработчик не знает (и не должен знать)
о том, каким будет реальный тип первого операнда.
Это позволяет очень гибко расширять возможности применения оператора вывода -
достаточно лишь найти (в готовых библиотеках) или самостоятельно реализовать наследник с нужным поведением,
и передать этот объект в качестве левого операнда оператора.
**При этом сам оператор вывода не нужно каким-либо образом менять или даже перекомпилировать для поддержки нового типа данных.**

На данный момент внимательный читатель должен был бы задаться вопросом:
в примере выше при применении оператора `<<` в различных сценариях (при разных типах левого операнда)
в конечном счёте не может выполняться один и тот же код,
ведь для распечатки в стандартный поток вывода, вывода в файл, распечатки в буфер памяти,
передачи данных по сети и т. д. в конечном счёте где-то "под капотом"
должен выполняться свой собственный код для каждого сценария.
Другими словами, классам-наследникам необходим некоторый механизм,
который позволял бы кастомизировать ("настраивать") своё поведение.
Механизм, позволяющий сделать такую кастомизацию, рассмотрен далее в пункте
[1.6 Переопределение методов и позднее связывание](#16-переопределение-методов-и-позднее-связывание).

Обратим внимание, что кастомизация поведения наследника - это забота самого наследника,
но не того кода (в данном случае, оператора `<<`), который оперирует с объектом на уровне базового класса.
Именно этот факт позволяет расширять поведение оператора `<<` (в общем случае - поведение любого метода/функции)
просто за счёт добавления нового типа наследника, никак не модифицируя при этом
уже существующий и отлаженный код самого оператора (метода, функции).



## 1.4 Формальный и фактический типы

При работе с иерархиями классов возникают два следующих понятия.

**Формальный тип** - это формальный тип переменной, через которую идёт обращение к объекту в коде программы.

**Фактический тип** - это фактический (реальный) тип объекта.

⚠ Формальный тип всегда известен на этапе компиляции.
Фактический тип известен во время выполнения программы, но может быть неизвестен на этапе компиляции.

Из примера выше:
```cpp
std::ostream& operator<<(std::ostream& stream, const Point& p);
```

Здесь формальный тип параметра `stream` - `std::ostream`.
Однако фактическим типом `stream` может быть как сам `std::ostream`,
так и `std::iostream`, `std::fstream`, `std::stringstream` или
любой наследник любого из перечисленных типов.
  
  

## 1.5 Перекрытие методов и раннее связывание

Рассмотрим следующий код:
```cpp
#include <iostream>
#include <memory>

struct A {
  A() = default;

  void m() const { std::cout << "A\n"; }

  A(const A&) = delete;            // Объяснения см. в нормах
  A& operator=(const A&) = delete; // Объяснения см. в нормах
  virtual ~A() = default;          // Объяснения см. в нормах
};

struct B : public A {
  void m() const { std::cout << "B\n"; }
};

int main() {
  std::shared_ptr<B> pbb = std::make_shared<B>();
  pbb->m();

  std::shared_ptr<A> pab = pbb;
  pab->m();
}
```

Зададимся вопросом: а что же будет выведено в консоль?

Первый блок кода вопросов вызвать не должен:
```cpp
std::shared_ptr<B> pbb = std::make_shared<B>();
pbb->m();
```

Здесь формальный и фактический типы совпадают. Будет выведено `B`.

А вот во втором блоке кода формальный и фактический типы различаются:
```cpp
// Указатель: формально на тип A, фактически на тип B
std::shared_ptr<A> pab = pbb;
pab->m();
```

Какой же метод `m` будет вызван - из базового класса `A` или из унаследованного класса `B`?

По умолчанию для всех методов применяется **механизм раннего связывания**.
Это означает, что вызываемая реализация метода определяется на **этапе компиляции** (поэтому и "раннее").
Так как на этапе компиляции гарантированно известен только формальный тип,
то вызываемая реализация будет определяться формальным типом.
Будет выведено `A`.

Когда класс-наследник определяет метод с точно таким же заголовком, как и в базовом классе,
и при этом применяется механизм раннего связывания, то говорят о **перекрытии** метода
(класс `B` перекрывает реализацию метода `m`, унаследованную из класса `A`).

Как вы догадываетесь, перекрытие метода не позволяет решить задачу кастомизации поведения наследника,
если пишется функция, работающая с формальным типом базового класса:
```cpp
void f(const A& a) {
  a.m();
}
```
Если для метода `m` применяется механизм раннего связывания,
то совершенно не важно, какой фактический тип скрывается под `a`.
Всегда будет вызываеться реализация `m` из класса `A`.
Таким образом, наследник не сможет кастомизировать поведение метода `m` в функции `f`.



## 1.6 Переопределение методов и позднее связывание

Итак, возникает необходимость в **механизме позднего связывания**,
когда вызываемая реализация метода должна определяться не формальным типом объекта, а фактическим.
Так как фактический тип объекта в общем случае известен только во время выполнения,
решение о том, какую именно реализацию надо вызывать, принимается во время выполнения программы (поэтому и "позднее").

Для применения механизма позднего связывания метод должен быть объявлен **виртуальным**.
Если при этом в наследнике объявляется метод с точно таким же заголовком,
то в этом случае говорят о **переопределении метода**:

```cpp
#include <iostream>
#include <memory>

struct A {
  A() = default;

  virtual void m() const { std::cout << "A\n"; }

  A(const A&) = delete;            // Объяснения см. в нормах
  A& operator=(const A&) = delete; // Объяснения см. в нормах
  virtual ~A() = default;          // Объяснения см. в нормах
};

struct B : public A {
  void m() const override { std::cout << "B\n"; }
};

int main() {
  std::shared_ptr<B> pbb = std::make_shared<B>();
  pbb->m();

  std::shared_ptr<A> pab = pbb;
  pab->m();
}
```

В этом примере вызываемая реализация определяется фактическим типом объекта.
Оба вызова выведут `B`.

Отметим несколько моментов касаемо переопределения виртуального метода.
- Ключевое слово `virtual` обязательно для указания только в базовом классе.
  Данный метод с данным заголовком становится виртуальным для всех наследников любого уровня наследования.
  В наследнике ключевое слово `virtual` указывать уже необязательно.
  Сделать виртуальный метод невиртуальным наследник уже не сможет.
  Но наследник может запретить переопределение метода для своих наследников,
  если переопределит метод со спецификатором [`final`](https://en.cppreference.com/w/cpp/language/final).
  Этот же спецификатор может применяться на весь класс целиком для запрета дальнейшего наследования от этого класса.
- Наследник не обязан переопределять виртуальный метод.
  В этом случае будет вызываться унаследованная реализация (т. е. реализация из базового класса).
- Если наследник переопределяет метод, то такой метод может быть помечен ключевым словом `override`.
  Это дополнительный барьер безопасности: компилятор будет проверять,
  что вы действительно **переопределяете** метод, то есть в базовом классе обязан существовать виртуальный метод
  с точно таким же заголовком, иначе будет ошибка компиляции.
- При переопределении рекомендуется не указывать ключевое слово `virtual`,
  но всегда указывать ключевое слово `override`.
  Дело в том, что ошибиться очень легко...
  - Например, в базовом классе объявлен некий виртуальный константный метод.
    Если в наследнике вы объявите точно такой же метод без спецификатора `override` и забудете спефицикатор `const`,
    то это будет не **переопределение**, а всего лишь перегрузка.
    Однако если указан спецификатор `override`, то будет ошибка компиляции
    (так как вы явно говорите компилятору, что должно быть переопределение,
    и если компилятор не найдёт виртуальный метод с точно таким же заголовком в одном из базовых классов,
    он сообщит об ошибке).

**Подведём самые важные итоги.**
- **Для невиртуальных методов вызываемая реализация определяется формальным типом и
  всегда известна на этапе компиляции.**
  Если наследник определяет метод с точно таким же заголовком, говорят о **перекрытии метода**.
  Как правило, в общем случае перекрытие использоваться не должно,
  так как вызываемая реализация метода должна определяться фактическим типом объекта,
  а не типом переменной, через которую идёт обращение к объекту в коде.
- **Для виртуальных методов вызываемая реализация определяется фактическим типом и
  в общем случае известна только во время выполнения.**
  Если наследник определяет метод с точно таким же заголовком, говорят о **переопределении метода**.
- Класс, в котором есть хотя бы один виртуальный метод (унаследованный или определённый явно),
  называется **полиморфным**.
- Динамическое приведение типов (`dynamic_cast`) может использоваться только для полиморфных типов.
- Переопределение метода позволяет наследнику кастомизировать своё поведение,
  даже если потребитель (и это самое главное!) работает с формальным типом базового класса.
  Это позволяет расширять функционал добавлением новых типов-наследников,
  не изменяя при этом уже существующий и проверенный код, который знает только про базовый класс
  и не знает (и не должен знать!) про любых наследников.
  - Посмотрите ещё раз на пример выше с оператором `<<`.
    Был описан оператор вывода объекта типа `Point` в объект типа `std::ostream`.
    Такой оператор ничего не знает и не должен знать про фактические типы `std::ostream`,
    которые определяют реальный приёмник данных.
    Если клиенту потребуется вывести объект типа `Point` в какой-то специфичный приёмник,
    ему нужно будет лишь определить правильный наследник `std::ostream` и "подсунуть" объект этого типа
    в качестве левого операнда `<<`. **За счёт механизма позднего связывания при этом менять или
    даже перекомпилировать код оператора `<<` не придётся.**

**Факультативная заметка.**
Внимательные читатели, посмотрев на документацию классов `std::ostream`, `std::istream` и `std::iostream` увидят,
что эти классы не являются полиморфными (в них нет виртуальных методов).
Ответ прост: эти классы являются всего лишь удобными обёртками над объектом полиморфного типа
[`std::streambuf`](https://en.cppreference.com/w/cpp/io/basic_streambuf).
Это так называемая идиома невиртуального интерфейса.
Детальнее про эту идиому можно почитать здесь:
- [WikiBooks. More C++ Idioms. Non-Virtual Interface](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface)
- [Dynamic polymorphism: the non-virtual interface design pattern](https://robinmoussu.gitlab.io/blog/post/2019-05-07_nvi/)



Нормы:
- [C.67: A polymorphic class should suppress public copy/move](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c67-a-polymorphic-class-should-suppress-public-copymove)
- [C.127: A class with a virtual function should have a virtual or protected destructor](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor)
- [C.128: Virtual functions should specify exactly one of virtual, override, or final](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final)
- [C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of public copy construction/assignment](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-constructionassignment)
- [C.140: Do not provide different default arguments for a virtual function and an overrider](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider)
- [C.153: Prefer virtual function to casting](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c153-prefer-virtual-function-to-casting)



## 1.7 Абстрактные классы и интерфейсы

Напомним, что наследники не обязаны переопределять виртуальные методы.
Однако часто возникает ситуация, когда на уровне базового класса давать какую-либо реализацию бессмысленно
(нет адекватной реализации по умолчанию и каждый наследник должен переопределить метод по-своему).
В этом случае можно использовать **чисто виртуальный метод**, помечаемый как `= 0`:
```cpp
struct A {
  A() = default;

  virtual void m() const = 0;

  A(const A&) = delete;            // Объяснения см. в нормах
  A& operator=(const A&) = delete; // Объяснения см. в нормах
  virtual ~A() = default;          // Объяснения см. в нормах
};
```

Такой метод может не имеет определения вообще.

Класс, который содержит хотя бы один чисто виртуальный метод, называется **абстрактным**.

Объекты абстрактных классов создавать нельзя.
Потому что формально такие классы не являются полностью определёнными.
Если вы даже создадите объект абстрактного класса,
то что должно происходить при вызове чисто виртуального метода `m`,
который не переопределён, то есть может не иметь никакого тела (определения)?

Любой наследник абстрактного класса также становится абстрактным до тех пор,
пока не переопределит все чисто виртуальные методы.

Таким образом, использование чисто виртуальных методов в базовом классе обязывает конечных
(находящихся в самом низу иерархии наследования) наследников тем или иным образом
явно переопределить все чисто виртуальные методы.

**Примечание.**
Чисто виртуальный метод на самом деле может иметь тело,
однако это не отменяет абстрактность класса и требование явного переопределения
такого метода для того, чтобы снять абстрактность.
При этом наследники имеют возможность при переопределении вызвать унаследованную реализацию.
Однако такие сценарии не входят в рамки нашего курса.

Класс, который содержит только чисто виртуальные методы (за исключением технических методов, например,
запрет каких-либо конструкторов или операторов), называется **интерфейсом**.
Реже такие классы ещё называют **протокольными**.
По сути интерфейсы описывают общий протокол для взаимодействия с любым типом из иерархии наследников -
какие методы могут быть вызваны у любого объекта из иерархии независимо от его конкретного типа.
При этом конечные типы иерархии **реализуют** протокол - переопределяют все чисто виртуальные методы.

**Примечание.**
В C++ и Python понятие интерфейса является лишь соглашением на уровне разработчиков.
С точки зрения синтаксиса понятие интерфейса не существует.
В C++ это всего лишь абстрактный класс, содержащий только чисто виртуальные методы.
В других объектно-ориентированных языках программирования понятие интерфейса существует, как правило,
как отдельная полноценная синтаксическая конструкция, определяемая собственным ключевым словом. См., например:
- [C#: ключевое слово `interface`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)
- [Go: ключевое слово `interface`](https://go.dev/tour/methods/9)
- [Java: ключевое слово `interface`](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html)
- [Kotlin: ключевое слово `interface`](https://kotlinlang.org/docs/interfaces.html)
- [PHP: ключевое слово `interface`](https://www.php.net/manual/en/language.oop5.interfaces.php)
- [Rust: ключевое слово `trait`](https://doc.rust-lang.org/book/ch10-02-traits.html)
- [Swift: ключевое слово `protocol`](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols)
- [TypeScript: ключевое слово `interface`](https://www.typescriptlang.org/docs/handbook/2/objects.html)

Обратите внимание, что во всех примерах по вышеперечисленным ссылкам у всех языков нет "технического бремени",
которое есть у C++ (связанное с явным запретом операций копирования и определением виртуального деструктора).
Однако, все эти языки появились **значительно позже** C++ и, так сказать, имели возможность *поучиться на чужих ошибках* (это достаточно своевольная формулировка; в конце концов можно настаивать на том,
что наличие некоторой обратной совместимости с Си - это не недостаток, а фича C++).

См. также:
- [Википедия. Интерфейс (объектно-ориентированное программирование)](https://ru.wikipedia.org/w/index.php?title=%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)&stable=1)

Нормы:
- [C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only)
- [C.121: If a base class is used as an interface, make it a pure abstract class](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class)
- [C.126: An abstract class typically doesn’t need a user-written constructor](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c126-an-abstract-class-typically-doesnt-need-a-user-written-constructor)
- [I.25: Prefer empty abstract classes as interfaces to class hierarchies](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i25-prefer-empty-abstract-classes-as-interfaces-to-class-hierarchies)



## 1.8 Пример

Пусть необходимо написать программу, которая должна работать с математическими функциями одного аргумента.
Данную задачу можно рассматривать как разработку компонента
[системы компьютерной алгебры](https://ru.wikipedia.org/w/index.php?title=%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%BE%D0%B9_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D1%8B&stable=1),
которая, в свою очередь, может являться частью такого сложного программного комплекса, как, например, [Wolfram Alpha](https://www.wolframalpha.com/).

Конкретные математические функции могут быть совершенно разными и предусмотреть заранее
все те математические функции, которые могут понадобиться, невозможно.

Более того, со временем, по мере развития программы, постепенно должны появляться всё новые и новые математические функции.

В такой ситуации необходимо ввести интерфейс для взаимодействия с такими математическими функциями.

При этом можно даже начать писать какой-то содержательный код, не имея реальных классов-наследников.
Это особенно важно при разработке в команде.
Как только определён интерфейс, одна часть людей может начать писать код, который работает на уровне этих интерфейсов.
В то время как другая часть людей параллельно может начать разрабатывать реализации этих интерфейсов.

Итак, определим интерфейс (протокол) для взаимодействия с любой математической функцией от одного аргумента:
```cpp
class Function {
public:
  Function(const Function&) = delete;
  Function& operator=(const Function&) = delete;

  virtual float compute(float x) const = 0;

  virtual ~Function() = default;

protected:
  Function() = default;
};
```

Отметим, что содержательно такой интерфейс содержит только один метод `compute`
для вычисления значения функции для заданного значения аргумента `x`.
Всё остальное является "техническим бременем".

Для простоты демонстрации намеренно оставим данный интерфейс таким тривиальным.
В качестве самостоятельного упражнения вы можете расширить протокол, добавив, например, такие методы, как:
- получение функции-производной;
- получение функции-первообразной;
- другие методы, которые, по-вашему, должны быть у объекта любой математической функции от одного аргумента.

Имея такой интерфейс, можно начать писать абстрактный код,
который не зависит от конкретных типов математических функций.

Например, можно написать функцию для численного нахождения точки минимума в заданном интервале:
```cpp
float min_location(const Function& f, const float x1, const float x2, const float step) {
  float min_x = x1;
  float min_y = f.compute(min_x);
  
  float x = x1 + step;
  while (x <= x2) {
    const float y = f.compute(x);
    if (y < min_y) {
      min_x = x;
      min_y = y;
    }
    x += step;
  }
  
  return min_x;
}
```

**Ещё раз обратим внимание на всю мощь динамического полиморфизма во всей своей абстрактной красоте.**
Функция `min_location` работает с интерфейсом `Function`.
Она ничего не знает о реальном типе параметра `f`.
Под `f` может скрываться какая угодно математическая функция.
Более того, под `f` может скрываться объект любого типа -
единственное ограничение заключается только в том, что этот тип должен наследоваться от `Function`
(или, другими словами, должен реализовывать протокол `Function`).
Что касается самой функции `min_location`, то несмотря на незнание конкретного типа,
она всё равно может сделать некоторую работу, так как знает:
какой-бы тип ни скрывался под `f`, он реализует протокол `Function`, а значит,
с объектом `f` можно выполнять любые операции, которые предусмотрены в протоколе
(в данном случае - это вызов метода `compute`).

При этом при добавлении новых математических функций не придётся никак менять или
перекомпилировать код функции `min_location`.
Он автоматически будет работать с любым, наперёд неизвестным
(на момент написания самой функции `min_location`) типом, реализующим протокол `Function`.

Чтобы вызвать `min_location`, сначала нужно откуда-то получить реальную математическую функцию.
Давайте напишем класс-наследник, описывающий квадратичную функцию $f(x) = ax^2 + bx + c$:
```cpp
class QuadraticFunction : public Function {
private:
  float _a;
  float _b;
  float _c;
  
public:
  QuadraticFunction(const float a, const float b, const float c) : _a(a), _b(b), _c(c) { }

  float a() const noexcept { return _a; }
  float b() const noexcept { return _b; }
  float c() const noexcept { return _c; }
  
  float compute(const float x) const override {
    return _a * x * x + _b * x + _c;
  }
};
```

Так как `QuadraticFunction` переопределяет единственный чисто виртуальный метод,
класс перестаёт быть абстрактным. Значит, можно создать реальный объект этого типа и,
например, вызвать `min_location`, чтобы численно найти точку минимума в указанном интервале.

Например, создадим объект математической функции $f(x)=2x^2 + x$.
Это квадратичная функция с параметрами $a = 2$, $b = 1$ и $c = 0$:
```cpp
int main() {
  const QuadraticFunction qf(2, 1, 0);
  std::cout << "min_location = " << min_location(qf, -10, 10, 0.01) << '\n';
  // Возможный вывод: -0.249866
}
```
Напомним, что точка минимума для функции $f(x)=ax^2 + bx + c$ при $a > 0$
определяется аналитическим выражением $-\frac{b}{2a}$.
Для математической функции $f(x)=2x^2 + x$ точка минимума это $-\frac{1}{4}$.
Видно, что наш численный алгоритм с точностью до шага перебора `step = 0.01` дал правильный результат.



# 2 Обязательное задание

## 2.1 Общее задание

1. Реализовать иерархию классов согласно варианту.
   - Реализовать базовый класс (абстрактный класс или интерфейс) и несколько наследников.
   - Описание варианта содержит только базовый минимум.
     При реализации предусмотреть методы чтения (методы записи - на своё усмотрение).
     По своему усмотрению можно добавить дополнительные поля и методы, если в них есть смысл.
2. Написать функцию над контейнером согласно варианту
   (в зависимости от варианта, такой функции может не быть вообще или их может быть несколько):
   - функция должна принимать контейнер (`std::vector`) объектов типа базового класса и,
     может быть, какие-либо дополнительные параметры;
   - если функция ищет объект согласно некоторому предикату, то функция должна вернуть:
     - указатель на первый объект, удовлетворяющий предикату;
     - `nullptr`, если контейнер пустой или такого объекта нет.
3. Если в варианте явно не указано другое, то в `main` реализовать консольный интерфейс
   в виде меню со следующими пунктами:
   - вставка нового элемента в контейнер (запрашивается индекс вставки,
     тип создаваемого объекта и необходимые данные для создания объекта выбранного типа);
   - удаление элемента из контейнера (запрашивается индекс удаляемого элемента);
   - распечатка текущего содержимого контейнера;
   - демонстрация использования переопределяемых методов;
   - вызов функции над контейнером согласно варианту (если таких функций несколько,
     каждая функция оформляется в виде отдельного пункта меню) и распечатка найденного объекта
     (или вывод сообщения об его отсутствии).

**Требование.**
При выполнении лабораторной работы должно использоваться правило ноля.
Управление памятью должны осуществляться с помощью `std::vector` и умных указателей.



## 2.2 Варианты

Относительно усложнённые варианты помечены (*).
Такие пометки стоят только для удобства выбора варианта.
Дополнительные баллы за усложнённый вариант не начисляются.

1. **Банковские счета `Account`**
   - Классы-наследники:
     - расчётный;
     - вкладовый;
     - кредитный.
   - Состояние:
     - ФИО владельца счета;
     - текущий баланс;
     - только для вкладового и кредитного счетов: % годовой ставки.
   - Переопределяемый метод:
     - начисление/списывание процентов за расчётный месяц:
       - для расчётного счёта - ничего не происходит;
       - для вкладового счёта - увеличение текущего баланса на величину
         `текущий баланс * %_годовой_ставки / 12`;
       - для кредитного счёта - уменьшение текущего баланса на величину
         `текущий_баланс * %_годовой_ставки / 12`, но только если `текущий_баланс < 0`.
   - Функции над контейнером:
     - начислить/списать проценты по всем счетам;
     - найти счёт с минимальным текущим балансом;
     - найти счёт с максимальным текущим балансом.

2. **Человек из социального слоя `Citizen`**
   - Классы-наследники:
     - школьник;
     - студент;
     - пенсионер.
   - Состояние:
     - ФИО;
     - только для школьника:
       - название образовательного учреждения;
       - номер ученического билета;
       - флаг принадлежности к многодетной семье.
     - только для студента:
       - название образовательного учреждения;
       - номер зачётной книжки;
       - средний балл.
     - только для пенсионера:
       - СНИЛС;
       - стаж.
   - Переопределяемый метод:
     - расчёт социальной выплаты от государства по заданному значению МРОТ:
       - для школьников:
         - 0.5\*МРОТ, если из многодетной семьи;
         - 0 во всех остальных случаях.
       - для студентов:
         - 0, если средний балл меньше 3.5;
         - от 0.5\*МРОТ до 0.8\*МРОТ при среднем балле от 3.5 до 5 (зависимость линейная).
       - для пенсионера:
         - 0, если стаж меньше 5 лет;
         - от 1\*МРОТ до 4\*МРОТ при стаже от 5 до 30 лет (зависимоть линейная);
         - 5\*МРОТ при стаже более 30 лет.
   - Функция над контейнером:
     - найти человека с наибольшей социальной выплатной при заданном значении МРОТ.

3. **Сотрудники `Employee`**
   - Классы-наследники:
     - штатник;
     - совместитель.
   - Состояние:
     - ФИО;
     - дата наёма на работу;
     - только для штатников:
       - базовая ставка за 1 месяц работы.
     - только для совместителей:
       - базовая ставка за 1 час работы;
       - процент индивидуальной надбавки (от 0 до 5 %);
       - количество отработанных часов за последний месяц.
   - Переопределяемый метод:
     - расчёт заработной платы:
       - для штатных сотрудников фиксированная с надбавкой 0.5 % за каждый год работы в организации;
       - для совместителей почасовая (с возможностью индивидуальной надбавки).
   - функция над контейнером:
     - найти сотрудника с максимальной заработной платой.

4. **Геометрические фигуры на плоскости `Figure`**
   - Классы-наследники:
     - круг;
     - треугольник;
     - прямоугольник (со сторонами параллельными осям координат).
   - Состояние:
     - расположение и геометрия фигуры, предусмотреть вспомогательный класс `Point`.
   - Переопределяемые методы:
     - вычисление периметра;
     - вычисление площади;
     - вычисление минимального обрамляющего прямоугольника.
   - Функция над контейнером:
     - найти фигуру с максимальной площадью.

5. **Геометрические фигуры на плоскости `Figure`**
   - Классы-наследники:
     - эллипс (с полуосями, параллельными осям координат);
     - трапеция (с нижней и верхней стороной, параллельными осям координат);
     - прямоугольник (со сторонами, параллельными осям координат).
   - Состояние:
     - расположение и геометрия фигуры, предусмотреть вспомогательный класс `Point`.
   - Переопределяемые методы:
     - вычисление периметра;
     - вычисление площади;
     - вычисление минимального обрамляющего прямоугольника.
   - Функция над контейнером:
     - найти фигуру с минимальной площадью обрамляющего прямоугольника.

6. **Геометрические фигуры в пространстве `Figure`**
   - Классы-наследники:
     - шар;
     - цилиндр (в произвольной ориентации);
     - параллелепипед (с гранями, параллельными координатным плоскостям).
   - Состояние:
     - расположение и геометрия фигуры, предусмотреть вспомогательный класс `Point`.
   - Переопределяемые методы:
     - вычисление площади поверхности;
     - вычисление объёма.
   - Функция над контейнером:
     - найти фигуру с максимальным объёмом.

7. **Университетские занятия `Class`**
   - Классы-наследники:
     - лекции;
     - лабораторные работы;
     - практики.
   - Состояние:
     - название дисциплины;
     - количество часов $h$.
   - Переопределяемый метод:
     - вычисление количества оплачиваемых преподавателю часов $p$:
       - входные аргументы:
         - количество групп $n$;
         - количество подгрупп $m$ (обычно $m = 2 * n$, но так как для маленьких групп
           разделение на подгруппы может не производиться, полагать, что $n \leq m$).
       - порядок расчёта:
         - лекции читаются всему потоку сразу, поэтому для лекций $p = h$;
         - практики читаются по группам, поэтому для практик $p = n \cdot h$;
         - лабораторные ведутся по подгруппам, поэтому для лабораторных $p = m \cdot h$.
   - Функции над контейнером:
     - вычислить полное (по всем занятиям) количество оплачиваемых часов для заданной дисциплины
       по заданному названию дисциплины, $n$ и $m$;
     - найти дисциплину с максимальным количеством оплачиваемых часов (по всем занятиям)
       по заданному $n$ и $m$.

8. **Математические функции от одного аргумента `Function`**
   - Классы-наследники:
     - степенная функция $f(x) = ax^b$;
     - натуральный логарифм $f(x) = c \ln x$.
   - Состояние:
     - параметры функции.
   - Переопределяемые методы:
     - вычисление значения функции от заданного аргумента $x$;
     - получение производной функции (напоминание: производная функции - это тоже функция!);
     - получение первообразной функции (напоминание: первообразная функции - это тоже функция!)
       в возможных пределах реализуемых классов-наследников (то есть, если первообразная не выражается
       в виде одного из классов-наследников, требуемых согласно варианту, то можно бросить исключение).
   - Функция над контейнером:
     - найти функцию с минимальным значением производной при заданном аргументе $x$.

9. **Математические функции от одного аргумента `Function`**
   - Классы-наследники:
     - квадратичная функция $f(x) = ax^2 + bx + c$;
     - гармоническая функция $f(x) = a \cos(\omega x + \phi)$.
   - Состояние:
     - параметры функции.
   - Переопределяемые методы:
     - вычисление значения функции от заданного аргумента $x$;
     - получение производной функции (напоминание: производная функции - это тоже функция!);
     - получение первообразной функции (напоминание: первообразная функции - это тоже функция!)
       в возможных пределах реализуемых классов-наследников (то есть, если первообразная не выражается
       в виде одного из классов-наследников, требуемых согласно варианту, то можно бросить исключение).
   - Функция над контейнером:
     - найти функцию с максимальным значением при заданном аргументе $x$.

10. **Прогрессии чисел `Progression`**
    - Классы-наследники:
      - арифметическая прогрессия;
      - геометрическая прогрессия.
    - Состояние:
      - первый член прогрессии;
      - только для арифметической прогрессии: шаг прогресиии;
      - только для геометрической прогрессии: знаменатель прогрессии.
    - Переопределяемые методы:
      - вычисление $n$-го элемента последовательности при заданном $n$;
      - вычисление суммы первых $n$ элементов последовательности при заданном $n$.
    - Функция над контейнером:
      - найти прогрессию с максимальной суммой первых $n$ элементов при заданном $n$.

11. **Последовательность чисел `Sequence`**
    - Классы-наследники:
      - последовательность квадратов натуральных чисел
        с произвольным целым сдвигом $c$: $x_n = n^2 + c, ~ n \in \mathbb{N}$;
      - последовательность факториалов натуральных чисел: $x_n = n!, ~ n \in \mathbb{N}$.
    - Состояние:
      - только для последовательности квадратов: величина сдвига $c$.
    - Переопределяемый метод:
      - вычисление $n$-го элемента последовательности при заданном $n$.
    - Функция над контейнером:
      - найти последовательность с минимальным $n$-ым членом при заданном $n$.

12. **Последовательность чисел `Sequence`**
    - Классы-наследники:
      - последовательность кубов натуральных чисел $x_n = n^3, ~ n \in \mathbb{N}$;
      - последовательность чисел, кратных $c$: $x_n = \{c, 2c, 3c, 4c, ...\},  ~ c \in \mathbb{N}$.
    - Состояние:
      - только для последовательности чисел, кратных $c$: величина $c$.
    - Переопределяемый метод:
      - вычисление $n$-го элемента последовательности при заданном $n$.
    - Функция над контейнером:
      - найти последовательность с максимальным $n$-ым членом при заданном $n$.

13. **Транспортные средства `Vehicle`**
   - Классы-наследники:
     - легковой автомобиль;
     - грузовой автомобиль;
     - мотоцикл.
   - Состояние:
     - название модели;
     - объем двигателя $v$;
     - только для грузовых автомобилей: тоннаж $t$.
   - Переопределяемый метод:
     - расчёт транспортного налога по заданной базовой ставке $s$:
       - для легкового автомобиля: $s \cdot v$;
       - для грузового автомобиля: $s \cdot v \cdot (t/2 + 1)$;
       - для мотоцикла: $0.3 \cdot s \cdot v$.
   - Функция над контейнером:
     - найти транспорт с наибольшим значением транспортного налога.

14. **Транспортные средства `Vehicle`**
    - Классы-наследники:
      - железнодорожный транспорт;
      - водный транспорт;
      - воздушный транспорт.
    - Состояние:
      - название модели;
      - базовый тариф перевозки $k$ \[руб/(кг\*км)\];
      - только для водного транспорта: поощряющий коэффициент $0.8 \leq a \leq 1$ за большие расстояния доставки;
      - только для воздушного транспорта: тип двигателя (турбовинтовой или реактивный).
    - Переопределяемый метод:
      - расчёт цены транспортировки:
        - входные аргументы:
          - масса груза $m$ \[кг\];
          - расстояние $d$ \[км\].
        - алгоритм расчёта:
          - для железнодорожного транспорта: $k \cdot m \cdot d$;
          - для водного транспорта: $k \cdot m \cdot d \cdot a^{d / 10000}$;
          - для воздушного транспорта: $k \cdot m \cdot d \cdot \omega$, где:
            - для турбовинтового транспорта:
              - $\omega = 0.75$, если $d < 1000$;
              - $\omega = 1.25$, иначе.
            - для реактивного транспорта:
              - $\omega = 1.25$, если $d < 1000$;
              - $\omega = 0.75$, иначе.
    - Функция над контейнером:
      - найти транспорт с минимальной ценой транспортировки при заданных $m$ и $d$.

15. **(\*\*) Персонажи компьютерной игры `Character` (поединок PvP)**
    - Классы-наследники:
      - рыцарь;
      - ассасин;
      - берсерк.
    - Состояние:
      - количество очков жизни;
      - количество очков брони;
      - количество наносимого урона;
      - только для рыцаря: вероятность снизить урон вдвое;
      - только для ассасина: вероятность повторной атаки в тот же ход;
      - только для берсерка: вероятность утроенного урона.
    - Переопределяемые методы:
      - рассчитать наносимый урон;
      - принять урон;
      - применить "особое умение":
        - для рыцаря: увеличить собственную броню, но ослабить наносимый урон;
        - для ассасина: уворот от атаки;
        - для берсерка: увеличить урон и вероятность утроенного удара, но уменьшить броню.
    - В `main` создать двух персонажей указанного пользователем типа.
      Далее либо смоделировать бой, либо разработать интерактивную RPG-игру
      (см. второй факультативный пункт).
      - При моделировании за один раунд случайно выбирается либо атака, либо использование особого умения.
    - Все конкретные числовые значения величин (игровой баланс) подбирать самостоятельно.

16. **(\*\*) Персонажи компьютерной игры `Character` (командное PvE)**
    - Классы-наследники:
      - "танк";
      - "лекарь";
      - "боец";
      - NPC:
        - допускается NPC сделать не самостоятельным классом, а промежуточным базовым классом,
          от которого унаследовать более конкретные классы NPC
          (скажем, условно, "адская гончая", "приспешник тьмы" и т. д.).
    - Состояние:
      - количество очков жизни:
        - для "танка" должно быть повышенным;
        - для "лекаря" должно быть пониженным.
      - количество наносимого урона автоатакой:
        - для "танка" и "лекаря" должно быть пониженным;
        - для "бойца" должно быть повышенным.
      - доля генерируемой угрозы при нанесении урона или лечении:
        - для "лекаря" и "бойца" значение по умолчанию 1.0 (по одному очку угрозы за каждое очко урона или лечения);
        - для "танка" должно быть повышенным;
      - только для "танка":
        - вероятность уклонения (избежать урона вовсе);
        - вероятность парирования (понизить входящий урон на какую-то долю).
      - только для NPC:
        - текущий уровень угрозы для каждого игрока:
          - изначально значение угрозы равно 0;
          - если игрок атакует **текущего** NPC, то уровень угрозы этого игрока увеличивается;
          - если "лекарь" лечит **любого** игрока, то уровень угрозы "лекаря" увеличивается для всех NPC.
    - Переопределяемые методы:
      - рассчитать наносимый урон;
      - принять урон;
      - получить массив (`std::vector`) допустимых способностей
        (каждая способность должна иметь некоторый `cooldown` -
        время перезарядки, исчисляемое в количестве ходов):
        - для "танка":
          - "удар грома" - наносит урон всем целям;
          - "провокация" - обнуляет у одной цели уровень угрозы всех других игроков (кроме самого "танка").
        - для "лекаря":
          - "волна исцеления" - исцеляет одного игрока на какую-то значительную величину;
          - "цепное исцеление" - исцеляет всех игроков на какую-то умеренную величину.
        - для "бойца":
          - "точный выстрел" - наносит значительное количество урона одной цели;
          - "залп" - наносит умеренное количество урона всем целям.
        - для NPC:
          - можно вернуть пустой массив (если NPC использует только автоатаки) или
            разработать некоторые способности на свой выбор.
    - В `main` создать две команды.
      Первая команда из игроков - "танка", "лекаря" и "бойца".
      Вторая команда - из какого-то количества NPC.
      Далее либо смоделировать командный бой, либо разработать интерактивную RPG-игру
      (см. второй факультативный пункт).
      - При моделировании поведение игроков должно быть адекватным,
        они не должны применять способности случайным образом.
        Например, "лекарь" должен исцелять только тогда, когда в этом возникает реальная необходимость
        (например, если способность исцелит 20 очков жизни, а игрок потерял всего 5 очков жизни,
        применять способность, пока игрок не потеряет больше очков жизни, смысла нет).
        Кроме того, в идеале (но это необязательно) все игроки должны концентрировать урон на одной цели.
      - Каждый NPC всегда атакует того игрока, который имеет наибольший уровень угрозы для этого NPC.
        Если у NPC есть способности, то они могут их применять либо случайным образом,
        либо сразу по истечении времени восстановления.
    - Все конкретные числовые значения величин (игровой баланс) подбирать самостоятельно.
    - Для способностей следует завести отдельную иерархию классов.
    - Допускается незначительная модификация вышеприведённой механики боя.
    - Допускается ввести систему бафов-дебафов (положительных/отрицательных эффектов) -
      потребуется отдельная иерархия классов.

17. **(\*) Шахматные фигуры `ChessPiece` (пешка, слон, ладья)**
    - Классы-наследники:
      - пешка;
      - слон;
      - ладья.
    - Состояние:
      - цвет фигуры;
      - позиция;
      - только для пешки:
        - ориентация (может ходить вверх или вниз?);
        - первый ли это ход.
    - Переопределяемые методы:
      - без учёта других фигур на доске:
        - проверка возможности фигуры переместиться на указанные координаты;
        - проверка возможности фигуры атаковать на указанные координаты.
      - с учётом других фигур на доске:
        - проверка возможности фигуры переместиться на указанные координаты;
        - проверка возможности фигуры атаковать на указанные координаты.
    - Функция над контейнером:
      - найти фигуру, которая может переместиться на указанные координаты.

18. **(\*) Шахматные фигуры `ChessPiece` (конь, ферзь, король)**
    - Классы-наследники:
      - конь;
      - ферзь;
      - король.
    - Состояние:
      - цвет фигуры;
      - позиция.
    - Переопределяемые методы:
      - без учёта других фигур на доске:
        - проверка возможности фигуры переместиться на указанные координаты;
        - проверка возможности фигуры атаковать на указанные координаты.
      - с учётом других фигур на доске:
        - проверка возможности фигуры переместиться на указанные координаты;
        - проверка возможности фигуры атаковать на указанные координаты.
    - Функция над контейнером:
      - найти фигуру, которая может атаковать на указанные координаты.

19. **(\*) Моделирование объектов файловой системы `FileSystemObject`**
    (упрощённая симуляция [inode](https://ru.wikipedia.org/w/index.php?title=Inode&stable=1)).
    - Запрещено использовать `std::filesystem` (этот вариант лишь **моделирует** описание объектов файловой системы).
    - Классы-наследники:
      - каталог;
      - файл.
    - Состояние:
      - уникальный идентификатор (аналог номера индексного дескриптора,
        в нашем случае - просто уникальное число; идентификатор не изменяется на протяжении всей жизни объекта);
      - название (имя каталога или файла);
      - идентификатор родительского объекта, если он есть;
      - только для файла: размер в байтах.
    - Переопределяемые методы:
      - вычисление полного размера объекта файловой системы:
        - для каталога размер - это сумма размеров всех файлов, находящихся в нём на любом уровне вложенности.
      - построение абсолютного пути для объекта с указанными идентификатором.
    - Функция над контейнером:
      - поиск объекта с указанным идентификатором.

20. **(\*) Генераторы псевдослучайных чисел `PRNG`**
    - Классы-наследники:
      - ГПСЧ на основе [линейного конгруэнтного метода (LCG)](https://en.wikipedia.org/wiki/Linear_congruential_generator);
      - ГПСЧ на основе [регистра сдвига с линейной обратной связью (LFSR)](https://en.wikipedia.org/wiki/Linear-feedback_shift_register):
        - разрешается запрограммировать любую фиксированную конфигурацию на свой выбор.
    - Состояние:
      - все необходимые переменные в зависимости от типа ГПСЧ.
    - Переопределяемый метод:
      - вычисление следующего случайного числа.
    - Функция над контейнером:
      - поиск ГПСЧ с наибольшим следующим генерируемым числом
        (опционально: реализовать этот метод без изменения состояния анализируемых ГПСЧ).



## 2.3 Нормы

- [C.67: A polymorphic class should suppress public copy/move](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c67-a-polymorphic-class-should-suppress-public-copymove)
- [C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only)
- [C.121: If a base class is used as an interface, make it a pure abstract class](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class)
- [C.126: An abstract class typically doesn’t need a user-written constructor](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c126-an-abstract-class-typically-doesnt-need-a-user-written-constructor)
- [C.127: A class with a virtual function should have a virtual or protected destructor](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor)
- [C.128: Virtual functions should specify exactly one of virtual, override, or final](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final)
- [C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of public copy construction/assignment](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-constructionassignment)
- [C.133: Avoid protected data](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c133-avoid-protected-data)
- [C.140: Do not provide different default arguments for a virtual function and an overrider](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider)
- [C.145: Access polymorphic objects through pointers and references](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c145-access-polymorphic-objects-through-pointers-and-references)
- [C.146: Use dynamic_cast where class hierarchy navigation is unavoidable](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable)
- [C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error)
- [C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative)
- [C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new)
- [C.152: Never assign a pointer to an array of derived class objects to a pointer to its base](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base)
- [C.153: Prefer virtual function to casting](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c153-prefer-virtual-function-to-casting)
- [I.25: Prefer empty abstract classes as interfaces to class hierarchies](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i25-prefer-empty-abstract-classes-as-interfaces-to-class-hierarchies)
- [R.22: Use make_shared() to make shared_ptrs](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r22-use-make_shared-to-make-shared_ptrs)
- [R.23: Use make_unique() to make unique_ptrs](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r23-use-make_unique-to-make-unique_ptrs)
- [* R.24: Use std::weak_ptr to break cycles of shared_ptrs](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs)



# 3 Факультативное задание

1. Продемонстрировать работоспособность вашего проекта под операционной системой семейства Linux.
2. Разработайте пошаговую RPG-игру, взяв за основу один из следующих вариантов:
   - поединок PvP - см. 15-ый вариант;
   - командное PvE - см. 16-ый вариант.

   Должна использоваться визуализация с помощью SFML.
   Визуализация может быть весьма условной и схематичной (без текстур и анимации),
   но как минимум она должна отображать:
   - текущее состояние игроков (количество жизни - в виде текста или прогресс-бара);
   - применяемые умения/способности со временем восстановления, если оно есть
     (время восстановления - опять-таки в виде текста или прогресс-бара).

   Выбор цели и применение умений/способностей должны осуществляться интерактивно
   (с помощью клавиатуры или мыши).

   За этот пункт начисляется от 1 до 7 факультативных баллов в зависимости от уровня проработки
   архитектуры кода (включая все разработанные иерархии классов),
   игровой механики (включая игровой баланс) и визуализации в SFML-части.
